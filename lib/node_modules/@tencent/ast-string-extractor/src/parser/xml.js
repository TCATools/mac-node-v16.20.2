const sax = require('sax');

function parseXml(code) {
  const parser = sax.parser(true, { position: true });
  const strings = [];
  let currentTag = null;
  const convertedCode = code
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .replace(/&amp;/g, '&');

  // parser.onopentagstart = (node) => {
  //   tagStartLine = parser.line;
  //   tagStartCol = parser.column;
  // };

  // parser.onopentag = (node) => {
  //   currentTag = node;
  //   // 提取属性值
  //   // Object.entries(node.attributes).forEach(([name, value]) => {
  //   // });
  // };

  // 在原始代码中查找文本位置
  const findTextPosition = (text) => {
    const index = convertedCode.indexOf(text);
    if (index === -1) return null;
    
    let line = 1, col = 1;
    for (let i = 0; i < index; i++) {
      if (convertedCode[i] === '\n') {
        line++;
        col = 1;
      } else {
        col++;
      }
    }
    
    // 计算结束位置
    let endLine = line, endCol = col + text.length - 1;
    const textLines = text.split('\n');
    if (textLines.length > 1) {
      endLine = line + textLines.length - 1;
      endCol = textLines[textLines.length - 1].length + 1;
    }
    
    return { startLine: line, startCol: col, endLine, endCol };
  };

  parser.ontext = (text) => {
    const trimmed = text.trim();
    if (trimmed) {
      const positions = findTextPosition(text);
      if (!positions) return;
      strings.push({
        text: text,
        // raw: text,
        startLine: positions?.startLine || parser.line,
        startCol: positions?.startCol || parser.column,
        endLine: positions?.endLine || parser.line,
        endCol: positions?.endCol || parser.column
      });
    }
  };

  parser.onerror = (e) => { throw e; };
  parser.write(code).close();

  return strings;
}

module.exports = { parseXml };
