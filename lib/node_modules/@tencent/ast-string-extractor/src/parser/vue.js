const { parse } = require('@vue/compiler-sfc');
const { parse: parseTemplate } = require('@vue/compiler-dom');
const { parseCode: parseScript, extractStrings: extractScriptStrings } = require('./js-ts');

// 统一解析 Vue 文件
function parseVue(code, filePath) {
  const { descriptor } = parse(code, { sourceMap: true });
  const strings = [];

  // 解析模板
  if (descriptor.template) {
    const templateOffset = descriptor.template.loc.start.offset;
    const templateContent = descriptor.template.content;
    const templateAst = parseTemplate(templateContent, {
      sourceMap: true,
      filename: filePath
    });

    traverseTemplate(templateAst, templateContent, strings);
    strings.forEach(item => {
         item.startLine += getLineNumber(code, templateOffset) - 1
         item.endLine += getLineNumber(code, templateOffset) - 1
    })
  }

  // 解析脚本 (支持 JS/TS)
  if (descriptor.script || descriptor.scriptSetup) {
    const scriptOffset = (descriptor.script || descriptor.scriptSetup).loc.start.offset
    const scriptContent = (descriptor.script || descriptor.scriptSetup).content;
    const scriptAst = parseScript(scriptContent, 'vue-script.js', false);
    const res = extractScriptStrings(scriptAst, false)
    // 将res中的每个结果中的startLine和endLine分别加上scriptContent的起始行列号
    res.forEach(item => {
      item.startLine += getLineNumber(code, scriptOffset) - 1
      item.endLine += getLineNumber(code, scriptOffset) - 1
    })
    strings.push(...res)
  }

//   // 解析样式 (可选)
//   descriptor.styles.forEach(styleBlock => {
//     strings.push(...extractCssStrings(styleBlock.content));
//   });

  return strings;
}

// 遍历模板 AST
function traverseTemplate(ast, source, strings) {
  const walk = (node) => {
    // 处理元素属性
    if (node.type === 1 /* ElementNode */) {
      node.props.forEach(prop => {
        if (prop.type === 6 /* Attribute */ && prop.value) {
          addString({
            content: prop.value.content,
            loc: prop.value.loc,
            source,
            isStatic: !prop.name.startsWith(':')
          }, strings);
        }
      });
    }

    // 处理文本内容
    if (node.type === 2 /* TextNode */) {
      const text = node.content.trim();
      if (text) {
        addString({
          content: text,
          loc: node.loc,
          source,
          isStatic: true
        }, strings);
      }
    }

    // 处理插值表达式中的字符串 (如 {{ 'text' }})
    if (node.type === 5 /* Interpolation */) {
      const expr = node.content.content;
      const regex = /(['"])(.*?)\1/g;
      let match;
      while ((match = regex.exec(expr)) !== null) {
        const start = node.loc.start.offset + match.index;
        const end = start + match[0].length;
        strings.push({
          text: match[2],
        //   raw: match[0],
          startLine: getLineNumber(source, start),
          startCol: getColumnNumber(source, start),
          endLine: getLineNumber(source, end),
          endCol: getColumnNumber(source, end)
        });
      }
    }

    if (node.children) {
      node.children.forEach(walk);
    }
  };

  walk(ast);
}

// 辅助函数：计算行列号
function getLineNumber(source, offset) {
  return source.slice(0, offset).split('\n').length;
}

function getColumnNumber(source, offset) {
  const lines = source.slice(0, offset).split('\n');
  return lines[lines.length - 1].length + 1;
}

// 添加字符串记录
function addString({ content, loc, source, isStatic }, strings) {
  if (!isStatic) return; // 忽略动态绑定
  
  const start = loc.start.offset;
  const end = loc.end.offset;
//   const raw = source.slice(start, end);
  
  strings.push({
    text: content,
    // raw,
    startLine: getLineNumber(source, start),
    startCol: getColumnNumber(source, start),
    endLine: getLineNumber(source, end),
    endCol: getColumnNumber(source, end)
  });
}

module.exports = { parseVue };
