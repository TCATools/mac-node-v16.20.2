const { parse } = require('@babel/parser');
const traverse = require('@babel/traverse').default;
const ts = require('typescript');
const path = require('path');

// 统一解析接口
const parseCode = (code, filePath, isTypeScript) => {
  const ext = path.extname(filePath);
  if (isTypeScript) {
    return ts.createSourceFile(
      filePath,
      code,
      ts.ScriptTarget.Latest,
      true,
      ext === '.tsx' ? ts.ScriptKind.TSX : ts.ScriptKind.TS
    );
  } else {
    const plugins = ['jsx', 'decorators-legacy'];
    if (ext === '.jsx') plugins.push('flow'); // 可选：支持 Flow 语法
    return parse(code, {
      sourceType: 'module',
      plugins: plugins
    });
  }
};

const addString = (strings, text, start, end, isTypeScript) => {
  if (isTypeScript) {
    strings.push({
        text: text,
        startLine: start.line + 1,
        startCol: start.character + 1,
        endLine: end.line + 1,
        endCol: end.character,
    });
  } else {
    strings.push({
        text: text,
        startLine: start.line,
        startCol: start.column + 1,
        endLine: end.line,
        endCol: end.column,
    });
  }
}

// 字符串提取逻辑
const extractStrings = (ast, isTypeScript) => {
  const strings = [];

  if (isTypeScript) {
    const sourceFile = ast;
    const walk = (node) => {
      // 捕获常规字符串
      if (ts.isStringLiteral(node)) {
        const parent = node.parent;
        if (ts.isImportDeclaration(parent) && parent.moduleSpecifier === node) {
          return; // 跳过 import 语句的路径字符串
        }
        if (ts.isCallExpression(parent) && 
            parent.expression.getText() === 'require' &&
            parent.arguments[0] === node) {
          return; // 跳过 require() 的路径字符串
        }
        const start = sourceFile.getLineAndCharacterOfPosition(node.getStart());
        const end = sourceFile.getLineAndCharacterOfPosition(node.getEnd());
        addString(strings, node.text, start, end, isTypeScript);
      }
      // 前面已经捕获
      // 捕获 JSX 属性中的字符串（如 <div className="text" />）
      // if (ts.isJsxAttribute(node) && node.initializer) {
      //   const init = node.initializer;
      //   if (ts.isStringLiteral(init)) {
      //     const start = sourceFile.getLineAndCharacterOfPosition(init.getStart());
      //     const end = sourceFile.getLineAndCharacterOfPosition(init.getEnd());
      //     addString(strings, init.text, start, end, isTypeScript);
      //   }
      // }
      // 捕获 JSX 文本（如 <div>Hello</div> 中的 "Hello"）
      if (ts.isJsxText(node)) {
        const text = node.text.trim();
        if (text) {
          const start = sourceFile.getLineAndCharacterOfPosition(node.getStart());
          const end = sourceFile.getLineAndCharacterOfPosition(node.getEnd());
          addString(strings, node.text, start, end, isTypeScript);
        }
      }
      ts.forEachChild(node, walk);
    };
    walk(sourceFile);
  } else {
    traverse(ast, {
      // 常规字符串
      StringLiteral(path) {
        const { node, parent } = path;
        // 跳过模块导入语句中的字符串
        if (parent.type === 'ImportDeclaration' && parent.source === node) {
          return; // 跳过 import 语句的路径字符串
        }
        // 跳过 require() 的路径字符串
        if (parent.type === 'CallExpression' && 
            parent.callee.type === 'Identifier' &&
            parent.callee.name === 'require' &&
            parent.arguments[0] === node) {
          return;
        }
        addString(strings, node.value, node.loc.start, node.loc.end, isTypeScript);
      },
      // 模板字符串
      TemplateLiteral(path) {
        const { node } = path;
        if (node.quasis.length === 1) { // 忽略含插值的模板字符串
            addString(strings, node.quasis[0].value.cooked, node.loc.start, node.loc.end, isTypeScript);
        }
      },
      // JSX 文本（如 <div>text</div>）
      JSXText(path) {
        const text = path.node.value.trim();
        if (text) {
            addString(strings, text, path.node.loc.start, path.node.loc.end, isTypeScript);
        }
      },
      // 前面已经捕获
      // JSX 属性字符串（如 <div className="text" />）
      // JSXAttribute(path) {
      //   const value = path.node.value;
      //   if (value?.type === 'StringLiteral') {
      //       addString(strings, value.value, value.loc.start, value.loc.end, isTypeScript);
      //   }
      // }
    });
  }

  return strings;
};

module.exports = { parseCode, extractStrings };
